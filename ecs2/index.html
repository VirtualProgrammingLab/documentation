<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Core ECS - ViPLab</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">ViPLab</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Welcome to the Viplab documentation</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Ecs2 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active">Core ECS</a>
</li>
                                    
<li>
    <a href="example/" class="dropdown-item">Beispiele</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Rest <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../rest/" class="dropdown-item">ECS REST Interface</a>
</li>
                                    
<li>
    <a href="../rest/auths/" class="dropdown-item">Auths</a>
</li>
                                    
<li>
    <a href="../rest/econtent/" class="dropdown-item">Econtent</a>
</li>
                                    
<li>
    <a href="../rest/eventqueues/" class="dropdown-item">Eventqueues</a>
</li>
                                    
<li>
    <a href="../rest/memberships/" class="dropdown-item">memberships</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Viplab <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../viplab/" class="dropdown-item">Index</a>
</li>
                                    
<li>
    <a href="../viplab/exercises/" class="dropdown-item">/numlab/exercises</a>
</li>
                                    
<li>
    <a href="../viplab/interrupts/" class="dropdown-item">Interrupts</a>
</li>
                                    
<li>
    <a href="../viplab/results/" class="dropdown-item">/numlab/results</a>
</li>
                                    
<li>
    <a href="../viplab/solutions/" class="dropdown-item">/numlab/solutions</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Viplab3.0 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../viplab3.0/" class="dropdown-item">Index</a>
</li>
                                    
<li>
    <a href="../viplab3.0/computation/" class="dropdown-item">Computation JSON Message</a>
</li>
                                    
<li>
    <a href="../viplab3.0/computation_result/" class="dropdown-item">Computation Result JSON Message</a>
</li>
                                    
<li>
    <a href="../viplab3.0/computation_task/" class="dropdown-item">Computation Task JSON Message</a>
</li>
                                    
<li>
    <a href="../viplab3.0/computation_template/" class="dropdown-item">Computation Template JSON Message</a>
</li>
                                    
<li>
    <a href="../viplab3.0/versioning/" class="dropdown-item">JSON Object Versioning Rules</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href=".." class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="example/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#core-ecs" class="nav-link">Core ECS</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#http-header" class="nav-link">HTTP Header</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#http-standard-header" class="nav-link">HTTP standard header</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#addressing" class="nav-link">Addressing ==</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#community-names-and-ids" class="nav-link">Community names and ids ===</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#create-a-ressource" class="nav-link">Create a ressource ===</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="core-ecs">Core ECS</h1>
<h2 id="http-header">HTTP Header</h2>
<h3 id="application-specific-headers">Application specific headers</h3>
<ul>
<li>
<p>X-EcsAuthId:: Has to be a valid participant id. In a standard ECS
 configuration this HTTP header will be attached by the authentication process
 running on the proxy server.</p>
</li>
<li>
<p>X-EcsReceiverCommunities:: Has to be a valid community id/ids or community name/names.
 Adresses all participants joined the comimunity/communities. You are able to note
 multiple communities, either by name or by id, spaced by comma. Only allowed by <code>POST</code>.  </p>
</li>
<li>
<p>X-EcsReceiverMemberships:: Has to be a valid membership id/ids. Adresses all
 listed memberships. You are able to note multiple membersips spaced by comma.
 Only allowed by <code>POST</code>.</p>
</li>
<li>
<p>X-EcsSender:: Beschreibt bei einem <code>GET</code> auf eine Message/Queue Ressource
 den Absender der Nachricht in Form seiner Membership-ID. Wird ausschließlich
 vom ECS gesetzt/beschrieben. Gleichzeitig setzt der ECS</p>
</li>
<li><code>X-EcsReceiverCommunities</code> auf die entsprechende Community des Senders.
 Falls der Absender Teinehmer mehrerer Communities ist, bezeichnet X-!EcsSender
 eine Liste von Membership-IDs, entsprechend enthält auch</li>
<li><code>X-EcsReceiverCommunities</code> eine korrespondierende Liste an Communities.</li>
</ul>
<p>X-EcsQueryStrings:: Used to provide [[#querystrings|querystrings]]. </p>
<h2 id="http-standard-header">HTTP standard header</h2>
<p>Accept:: Content-Types that are acceptable.
 Content-Type:: The mime type of the body of the request (used with POST and PUT requests).
 If-None-Match:: Allows a 304 Not Modified to be returned if content is unchanged.
 Cookie:: An HTTP cookie previously sent by the server with Set-Cookie.
 Content-Type:: The mime type of this content.
 ETag:: An identifier for a specific version of a resource.
 Location:: Used in redirection, or when a new resource has been created.
 Set-Cookie:: An HTTP cookie.</p>
<h2 id="addressing">Addressing ==</h2>
<p>In order to communicate to each other you have to provide a unique address.
These addresses can either be a so called membership id or a community id or
community name.</p>
<p>=== Membership IDs ===
These are unique ids in the scope of an ECS. They establish a relationship
between a participant and a community:</p>
<p><code>+------------+ 1        N +-----------+ N        1 +-----------+</code>&lt;<BR>&gt; 
<code>|participants|------------|memberships|------------|communities|</code>&lt;<BR>&gt;
<code>+------------+            +-----------+            +-----------+</code></p>
<p>Therefore a participant can be associated to different communities. Every
participant can inquire his membership ids by calling the
[[#memberships|memberships]]
ressource.</p>
<h2 id="community-names-and-ids">Community names and ids ===</h2>
<p>A community can be referenced by his community id (cid) or his community name.
If you address a community you implicit address all members of the community.
This applies also to the sender joining the receiver community if the sender
has set his ''community_selfrouting'' flag (default off), otherwise the sender
will be implicitly excluded from the receiver list. Every participant
can inquire his communities memberships by calling the
[[#memberships|memberships]]
ressource. </p>
<h2 id="create-a-ressource">Create a ressource ===</h2>
<p>If you want to <code>POST</code> to a ressource you have to provide either a
<code>X-EcsReceiverMemberships</code> or <code>X-EcsReceiverCommunities</code> header or both
together. </p>
<p>If you want to address a single membership or a dedicated number of
memberships you have to set the {{{X-EcsReceiverMemberships}}} header. This
header can have a list of values, e.g.
{{{
X-EcsReceiverMemberships: 3,6,47
}}}</p>
<p>If you want to address a community you have to set the
{{{X-EcsReceiverCommunities}}} header. This header can have a list of values,
e.g.
{{{
X-EcsReceiverCommunities: SWS,23,25
}}}</p>
<p>=== Get a ressource ===
If you <code>GET</code> a ressource then the ECS set the <code>X-EcsSender</code> and the
<code>X-EcsReceiverCommunities</code> header to show you from whom and where your received
message comes. If there is a list of <code>X-EcsReceiverCommunities</code> values than
there is also a list of corresponding <code>X-EcsSender</code> values, i.e. the sending
participant is member of multiple communities and addressed his message to
multiple communities also, e.g.
{{{
X-EcsSender: 3,19
X-EcsReceiverCommunities: UnisBW,SUV
}}}
This means that this message is addressed to you through two communities
(UnisBW, SUV) and the sender has the membership id 3 in UnisBW and 19 in SUV.</p>
<p>== Participants ==
=== Community selfrouting ===
If community selfrouting is activated at the participant (administration area)
you can decide if you also want to receive the message which you send to an
appropriate community, i.e. you get an event notification (if events on this
resource is activated) and you get it listed by its [[#list-ressource|list resource]]
and could access it through its [[#queue-ressource|queue resource]]. Of
course, as sender of the message you can always access it by its
[[#message-resource|message resource]].
=== Authentication ===
All participants have to be authenticated in order to use ECS services. A
participant is deemed to be authenticated if the <code>X-EcsAuthId</code> header is set
and the ECS knows it. The real authentication take place ''in front of'' the
ECS, normally at the Webserver (Proxy). But this depends on
configuration/installation of ECS:</p>
<p><code>+-----------+    .</code>&lt;<BR>&gt; 
<code>|   ECS     |   /_\</code>&lt;<BR>&gt; 
<code>| (RAILS)   |    |</code>&lt;<BR>&gt; 
<code>+-----------+    |</code>&lt;<BR>&gt; 
<code>|Rack Module|    |</code>&lt;<BR>&gt; 
<code>| (optional)|    |</code>&lt;<BR>&gt; 
<code>+-----------+    | Message</code>&lt;<BR>&gt; 
<code>| Webserver |    | Flow</code>&lt;<BR>&gt; 
<code>|  (Proxy)  |    |</code>&lt;<BR>&gt; 
<code>+-----------+    |</code>&lt;<BR>&gt; 
<code>|          |</code>&lt;<BR>&gt; 
<code>+-----------+    |</code>&lt;<BR>&gt; 
<code>|Participant|    |</code>&lt;<BR>&gt; 
<code>+-----------+</code></p>
<ul>
<li>Basic Auth ([[/nginx]], [[/apache]])</li>
<li>X.509 certificates ([[/nginx]], [[/apache]])</li>
</ul>
<p>=== Anonymous participants ===
The creation of a new anonymous participant automatically takes place by every
call to an ECS ressource if the calling participant didn't set <code>X-EcsAuthId</code> or
<code>Cookie</code> header, by setting a "Set-Cookie:" header in the response. On
subsequent calls the participant has to provide this cookie in a "Cookie"
header in order to be identified as the previously calling participant.
Additionally those participants were automatically joined to the <code>public</code>
community. Further their lifetime will be limited and all ressources will be
silently deleted after this lifetime becomes zero. With succesional accesses to
ECS this lifetime will be refreshed. For general cookie handling see also
[[http://en.wikipedia.org/wiki/HTTP_cookie|HTTP cookie]]. See also [[/examples|examples]].</p>
<p>== Ressource access restrictions ==
Of course this is best done on webserver. </p>
<ul>
<li>[[/nginx]], [[/apache]]</li>
</ul>
<p>&lt;<Anchor(statische_ressourcen)>&gt;
&lt;<Anchor(system_ressourcen)>&gt;
&lt;<Anchor(system_resources)>&gt;
== System Ressources ==
These are default ressources provided by any ECS installation. </p>
<p>&lt;<Anchor(events)>&gt;
=== Events queue ===
[[http://freeit.de/documents/ecsa/index.html#events_resource|see central documentation place]]</p>
<p>&lt;<Anchor(memberships)>&gt;
=== Memberships ===
[[http://freeit.de/documents/ecsa/index.html#memberships_resource|see central documentation place]]</p>
<p>=== Authorization through One Touch Tokens ===
[[http://freeit.de/documents/ecsa/index.html#auths_resource|see central documentation place]]</p>
<p>&lt;<Anchor(application_resources)>&gt;
== Anwendungsspezifische Ressourcen ==
Alle Ressourcen die explizit für eine Anwendung bereitgestellt werden sollen,
müssen vorab beim ECS konfiguriert werden. Dabei stellt der
ECS drei Typen von Ressourcen zur Verfügung:</p>
<ol>
<li>Message Ressource</li>
<li>Listen Ressource</li>
<li>Queue Ressource</li>
</ol>
<p>Allgemein steht hinter dem Ressourcenbegriff ein abstraktes Konzept. Ressourcen sind:</p>
<ul>
<li>eindeutig identifizierbar (im HTTP Kontext durch URIs)</li>
<li>haben eine oder mehrere Repräsentationen (z.B. JSON, XML, Text, ...)</li>
</ul>
<p>Für den Ressourcen Begriff ist es unerheblich, wie ihre Repräsentation
zustande kommt. Ob dies durch eine statische Datei oder durch ein Skript
(dynamisch) geschieht ist vollkommen egal. Einer URI/Ressource
ist dies von aussen nicht anzusehen (black box) und soll es auch nicht
sein (API, Entkopplung). Eine Bewertung einer Ressource aufgrund
''innerer'' Vorgänge und Gegebenheiten ist somit ebenfalls unerheblich,
ja sogar unzulässig.</p>
<p>Für alle weiteren Betrachtungen soll folgendes gelten:</p>
<ul>
<li>POST: Liefert {{{201}}} bei erfolgreichem anlegen der Ressource.</li>
<li>Bei Fehlern wird generell immer ein  {{{4XX}}} oder {{{5XX}}} Status Code zurückgegeben. </li>
<li>Bei nichtvorhandensein der Ressource ein {{{404}}} Status.</li>
<li>Bei Conditional-GET gibt {{{304}}} (Not Modified) an, dass sich die Ressource nicht geändert hat.</li>
<li>Entsprechende Ressource existiert und Operation ist erfolgreich, andernfalls Fehlermeldungen wie vorstehend beschrieben.</li>
</ul>
<p>&lt;<Anchor(resource_structure)>&gt; 
=== Ressourcenstruktur ===
{{{
/<projectnamespace>/<name>
/<projectnamespace>/<name>/details
/<projectnamespace>/<name>/<id>
/<projectnamespace>/<name>/<id>/receivers
/<projectnamespace>/<name>/<id>/details
/<projectnamespace>/<name>/fifo
/<projectnamespace>/<name>/lifo
}}}</p>
<p>&lt;<Anchor(persistent-messages)>&gt;
&lt;<Anchor(message-ressource)>&gt;
=== Message Resource ===
In einer Message Resource können Nachrichten für einen bestimmten Empfänger
abgelegt werden. Der Empfänger kann diese Nachrichten ebenfalls über diese
Ressource abholen. Eine Message Ressource kann so konfiguriert werden, dass die
in ihr abgelegten Nachrichten "persistent" gehalten werden, um so
neuhinzukommenden Participanten gegebenenfalls zum Abruf zur Verfügung zu stehen
(siehe [[#postrouting|Postrouting]]). Dies erlaubt den Aufbau einfacher und
verteilt genutzter Objektdatenbanken.</p>
<p>''GET'': Liefert Nachricht und gibt "200" Status Code. &lt;<BR>&gt;
''DELETE'': Löscht Nachricht und gibt "200" Status Code. Im Body wird die Repräsentation der gelöschten Ressource zurückgegeben.&lt;<BR>&gt;
''PUT'': Erneuert Nachricht und gibt "200" Status Code. &lt;<BR>&gt;
''POST'': unzulässig ("405" Method Not Allowed Statuscode).</p>
<p>Ressourcenstruktur: <code>/&lt;projectnamespace&gt;/&lt;name&gt;/&lt;id&gt;</code> &lt;<BR>&gt;
Bsp. einer Message-Ressource: <code>http://isblab.rus.uni-stuttgart.de/numlab/exercises/33</code></p>
<p>&lt;<Anchor(list_resources)>&gt;
&lt;<Anchor(list-ressource)>&gt;
&lt;<Anchor(listen-ressource)>&gt;
==== Subresource "details" ====
You can ask for detailed (meta) information of a posted
message. Only the original sender or a receiver can do that:</p>
<p>GET: /<projectnamespace>/<name>/<id>/details</p>
<p>You will get back something like this:</p>
<p><code>{</code>&lt;<BR>&gt;
<code>"receivers": [</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"itsyou": false,</code>&lt;<BR>&gt;
<code>"mid": 1,</code>&lt;<BR>&gt;
<code>"cid": 2</code>&lt;<BR>&gt;
<code>"pid": 19,</code>&lt;<BR>&gt;
<code>},</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"itsyou": false,</code>&lt;<BR>&gt;
<code>"mid": 4,</code>&lt;<BR>&gt;
<code>"cid": 3</code>&lt;<BR>&gt;
<code>"pid": 29,</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"senders": [</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"mid": 5</code>&lt;<BR>&gt;
<code>},</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"mid": 7</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"url": "courselinks/10",</code>&lt;<BR>&gt;
<code>"content_type": "application/json"</code>&lt;<BR>&gt;
<code>"owner": {</code>&lt;<BR>&gt;
<code>"pid": 3,</code>&lt;<BR>&gt;
<code>"itsyou": true</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;</p>
<p>The "receivers" and "senders" have corresponding arrays: The first array
entry in "senders" has been addressed the first array entry of
"receivers" and so on.</p>
<p>=== Listen Ressource ===
''GET'': Liefert URI Nachrichten-Liste und "200" Status Code. Wenn Liste leer (leerer HTTP-Body, "Content-Length: 0") trotzdem "200" Statuscode. &lt;<BR>&gt;
''DELETE'': unzulaessig ("405" Method Not Allowed Statuscode). &lt;<BR>&gt;
''PUT'': unzulaessig ("405" Method Not Allowed Statuscode). &lt;<BR>&gt;
''POST'': Legt neue Message-Ressource an.</p>
<p>Ressourcenstruktur: <code>/&lt;projectnamespace&gt;/&lt;name&gt;</code> &lt;<BR>&gt;
Bsp. einer Listen-Ressource: <code>http://isblab.rus.uni-stuttgart.de/numlab/exercises</code> &lt;<BR>&gt;
The returned <code>Content-Type</code> will be <code>text/uri-list</code>. The URI list will be
represented by [[http://www.rfc-ref.org/RFC-TEXTS/3986/chapter5.html|relative references]].
URIs are specified in [[http://www.rfc-ref.org/RFC-TEXTS/3986|RFC3986]].</p>
<p>==== Subresource "details" ====
Now it's possible to ask for detailed (meta) information of a list resource.
All querystrings supported my normal list resources could be used.
Only the original sender can do that:</p>
<p>GET: /<namespace>/<name>/details</p>
<p>You will get back something like this:</p>
<p><code>[</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"senders": [</code>&lt;<BR>&gt;
<code>&lt;&lt;BR&gt;&gt;
`    ],`&lt;&lt;BR&gt;&gt;
`    "receivers": [`&lt;&lt;BR&gt;&gt;</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"url": "courselinks/35",</code>&lt;<BR>&gt;
<code>"content_type": "text/plain",</code>&lt;<BR>&gt;
<code>"owner": {</code>&lt;<BR>&gt;
<code>"pid": 3,</code>&lt;<BR>&gt;
<code>"itsyou": true</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>},</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"senders": [</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"mid": 2</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"receivers": [</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"mid": 19,</code>&lt;<BR>&gt;
<code>"cid": 2,</code>&lt;<BR>&gt;
<code>"pid": 19,</code>&lt;<BR>&gt;
<code>"itsyou": false</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"url": "courselinks/36",</code>&lt;<BR>&gt;
<code>"content_type": "text/plain",</code>&lt;<BR>&gt;
<code>"owner": {</code>&lt;<BR>&gt;
<code>"pid": 3,</code>&lt;<BR>&gt;
<code>"itsyou": true</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>},</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"senders": [</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"mid": 2</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"receivers": [</code>&lt;<BR>&gt;
<code>{</code>&lt;<BR>&gt;
<code>"mid": 19,</code>&lt;<BR>&gt;
<code>"cid": 2,</code>&lt;<BR>&gt;
<code>"pid": 19,</code>&lt;<BR>&gt;
<code>"itsyou": false</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>],</code>&lt;<BR>&gt;
<code>"url": "courselinks/37",</code>&lt;<BR>&gt;
<code>"content_type": "text/plain",</code>&lt;<BR>&gt;
<code>"owner": {</code>&lt;<BR>&gt;
<code>"pid": 3,</code>&lt;<BR>&gt;
<code>"itsyou": true</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>}</code>&lt;<BR>&gt;
<code>]</code>&lt;<BR>&gt;</p>
<p>The first element of the returned array of the details list subresource
probably needs some explanation. Both senders and receivers are empty
lists. This mean that the appropriate message isn't any more addressed
to any participant. This further implies that all participants which
had been addressed in the past have been received the message from their
message queue. But why don't has been deleted the message then from the
ECS ? Because the resource has been configured to be "postrouted". If
that has not been the matter, ECS would has been removed the message.</p>
<p>&lt;<Anchor(querystrings)>&gt;
==== Querystrings ====
To affect the returned representation you could assign the following
querystrings to {{{X-EcsQueryStrings}}} header variable: </p>
<p>'''receiver'''&lt;<BR>&gt;
It's possible to filter the returned index from a list resource to only
those items to which the calling participant was formerly an addressed receiver:&lt;<BR>&gt;
<code>curl .... -H 'X-EcsQueryStrings: receiver=true' -X GET https://server/&lt;namespace&gt;/&lt;name&gt;</code>&lt;<BR>&gt;
This is also the default, therefore it could be omited.</p>
<p>'''sender'''&lt;<BR>&gt;
It's possible to filter the returned index from a list resource to
only those items to which the calling participant is the original
sender:&lt;<BR>&gt;
<code>curl .... -H 'X-EcsQueryStrings: sender=true' -X GET https://server/&lt;namespace&gt;/&lt;name&gt;</code></p>
<p>'''all'''&lt;<BR>&gt;
It's possible to filter the returned index from a list resource to
show all messages either as addressed receiver or as original sender:&lt;<BR>&gt;
<code>curl .... -H 'X-EcsQueryStrings: all=true' -X GET https://server/&lt;namespace&gt;/&lt;name&gt;</code></p>
<p>Using the {{{X-EcsQueryStrings}}} header variable is the recommended way to use querystrings.
If you have to assign multiple querystrings please delimit the querystrings by comma (,).</p>
<p>Of course you can also specify the querystring by appending it to the end of the resource url, e.g.</p>
<p><code>curl .... -X GET https://server/&lt;namespace&gt;/&lt;name&gt;?all=true</code>&lt;<BR>&gt;</p>
<p>&lt;<Anchor(message-queues)>&gt;
&lt;<Anchor(queue-ressource)>&gt;
=== Queue Resource ===
Die Queue Resource ist als Subressource einer Listen Ressource realisiert und kann entweder im ''lifo'' oder ''fifo'' Mode angesprochen werden:</p>
<p>''GET'': Liefert erste (fifo) oder letzte (lifo) Message-Ressource zurück. Gibt "200" Status Code zurück auch wenn keine Nachricht in Queue (leerer HTTP-Body, "Content-Length: 0"). &lt;<BR>&gt;
''DELETE'': unzulaessig ("405" Method Not Allowed Statuscode). &lt;<BR>&gt;
''POST'': Liefert erste (fifo) oder letzte (lifo) Message-Ressource zurück und löscht diese. Gibt "200" Status Code zurück auch wenn keine Nachricht in Queue (leerer HTTP-Body, "Content-Length: 0"). &lt;<BR>&gt;<br />
''PUT'': unzulaessig ("405" Method Not Allowed Statuscode).</p>
<p>Ressourcenstruktur: <code>/&lt;projectnamespace&gt;/&lt;name&gt;/fifo</code> oder <code>/&lt;projectnamespace&gt;/&lt;name&gt;/lifo</code> &lt;<BR>&gt;
Bsp. einer Queue-Ressource: <code>http://isblab.rus.uni-stuttgart.de/numlab/solutions/fifo</code></p>
<p>&lt;<Anchor(postrouting)>&gt;
=== Postrouting ===
If a resource has set his ''postroute'' flag, then all new participants will
get postrouted this resources e.g. if you have posted some messages to a
community named ''testcommunity'' and later joins a new participant to this
community, it will get postrouted the former posted messages.</p>
<p>&lt;<Anchor(participant_cluster)>&gt;
== Participant Cluster ==
Nachfolgend wird beschrieben, wie der ECS einen Cluster über eine beliebige
Anzahl von Participants bildet, diesen Cluster zur Benutzung bereitstellt und
wie dieser angesprochen wird.</p>
<p>=== Cluster-Bildung ===
Zunächst eine Grafik zur Verdeutlichung der Topologie:</p>
<p><code>+---------+  +---------+  +---------+</code>&lt;<BR>&gt; 
<code>| Partic. |  | Partic. |  | Partic. |</code>&lt;<BR>&gt;
<code>|    A    |  |    B    |  |    C    |</code>&lt;<BR>&gt;
<code>+---------+  +---------+  +---------+</code>&lt;<BR>&gt;
<code>|            |            |</code>&lt;<BR>&gt; 
<code>|            |            |</code>&lt;<BR>&gt; 
<code>+-----------------------------------+</code>&lt;<BR>&gt;
<code>|                ECS                |</code>&lt;<BR>&gt;
<code>+-----------------------------------+</code>&lt;<BR>&gt;
<code>|</code>&lt;<BR>&gt; 
<code>|</code>&lt;<BR>&gt; 
<code>+-----------------------------------+</code>&lt;<BR>&gt;
<code>| virtueller Participant (Cluster)  |</code>&lt;<BR>&gt;
<code>+--------+--------+--------+--------+</code>&lt;<BR>&gt;
<code>| Cluster| Cluster| Cluster| Cluster|</code>&lt;<BR>&gt;
<code>| Partic.| Partic.| Partic.| Partic.|</code>&lt;<BR>&gt;
<code>|    1   |    2   |   3    |   n    |</code>&lt;<BR>&gt;
<code>+--------+--------+--------+--------+</code></p>
<ol>
<li>
<p>Der ECS registriert einen virtuellen Participanten d.h. es wird nur ein
 Zertifikat (Cluster-Zertifikat) generiert und ausgegeben. Dieses eine
 Zertifikat wird für alle Participanten benutzt, die den gewünschten Cluster
 bilden sollen. Das reduziert zum einen die Zertifikatsverwaltung (generieren,
 ausgeben, erneuern, ...) und zum anderen läßt sich der Cluster vollkommen
 transparent skalieren, indem man einfach einen weiteren Cluster-Participanten
 mit dem Cluster-Zertifikat konfiguriert. Dazu sind keine Registrierungen oder
 Konfigurationen am ECS notwendig.</p>
</li>
<li>
<p>Nachrichten an den Cluster werden über eine Queue-Ressource
 geschickt. Die Adressierung des Clusters erfolgt einfach über den virtuellen
 Participanten. Jeder Cluster-Participant besorgt sich durch ein {{{DELETE}}}
 auf die Queue-Ressource eine neue Nachricht zur Bearbeitung. Dieses Abholen
 einer neuen Nachricht läuft innerhalb des Clusters konkurrierend unter allen
 Cluster-Participanten ab (message dispatching). </p>
</li>
</ol>
<p>{{{#!wiki comment/dotted
@stephan: virtuell heisst scheinbar. Dahinter steckt natürlich keinerlei extra
Instanz. Also keine zusätzliche Middleware oder sonstiges. Der Cluster wird
alleinig durch Verwendung eines gemeinsamen Zertifikats gebildet.</p>
<p>@stephan: Es ist eben gerade keine Änderung im "Backend" notwendig. Die
Cluster-Participants (Computation-Clients) können so bleiben wie sie sind,
benutzen aber dasselbe Zertifikat und werden vom ECS dadurch als ein einziger
Participant gesehen. Dies bezeichne ich als "virtuellen" Participant.
}}}</p>
<p>=== Cluster-Broadcasting ===
Da die Cluster-Participanten selbst nicht direkt/einzeln adressiert werden
können aber man trotzdem einzelne Cluster-Participanten ansprechen möchte,
bedient man sich dem sogenannten "broadcasting". Dazu wird eine
Message-Ressource (im weiteren als Broadcast-Ressource bezeichnet)
verwendet, in die ein Participant eine Nachricht schreibt.  Aus dem Cluster
heraus wird dann folgendermaßen auf diese Ressource zugegriffen:
 1. Jeder Cluster-Participant prüft die Broadcast-Ressource, ob dort eine neue
 Nachricht eingetroffen ist.  Ist dies der Fall wird die Nachricht idempotent
 aus der Broadcast-Ressource ausgelesen und überprüft, ob diese für den
 jeweiligen Cluster-Participanten gedacht ist. Wenn ja verarbeitet der
 Cluster-Participant die Nachricht.<br />
 2. Der ECS wird die Nachrichten in der Broadcast-Ressource nach
 voreingestellter Zeitdauer löschen (garbage collection).
 &lt;<Anchor(cluster_broadcasting_gc)>&gt;</p>
<p>&lt;<Anchor(filter_plugins)>&gt;
== Filter Plugins ==
Messages können über zur Laufzeit hinzufügbare Filter-Plugins manipuliert
werden. Ein Filter-Plugin (zukünftig als Filter bezeichnet) kann 5
unterschiedlichen Filter-Queues zugeordnet werden, die jeweils durch eine bestimmte
HTTP Operation getriggert werden. Die Filter-Queues werden dabei auf das
Dateisystem unterhalb des jeweiligen Basisverzeichnisses der Anwendung
abgebildet. Dabei richtet sich die Verzeichnisstruktur nach der
Ressourcen-URL ({{{/<project-name-space>/<name>}}} bzw. {{{/<project-name-space>/<name>/<id>}}}):  </p>
<ol>
<li>{{{show}}} Filter-Queue. Wird getriggert, sobald eine Queue/Message-Ressource abgerufen wird (GET): &lt;<BR>&gt;
 Filter-Queue Pfad: {{{app/controllers/<project-name-space>/filter/<name>/show}}}</li>
<li>{{{index}}} Filter-Queue. Wird getriggert, sobald eine Listen-Ressource abgerufen wird (GET): &lt;<BR>&gt;
 Filter-Queue Pfad: {{{app/controllers/<project-name-space>/filter/<name>/index}}}</li>
<li>{{{create}}} Filter-Queue. Wird getriggert, sobald eine Listen-Ressource aufgerufen wird (POST): &lt;<BR>&gt;
 Filter-Queue Pfad: {{{app/controllers/<project-name-space>/filter/<name>/create}}}</li>
<li>{{{update}}} Filter-Queue. Wird getriggert, sobald eine Queue/Message-Ressource aufgerufen wird (PUT): &lt;<BR>&gt;
 Filter-Queue Pfad: {{{app/controllers/<project-name-space>/filter/<name>/update}}}</li>
<li>{{{delete}}} Filter-Queue. Wird getriggert, sobald eine Queue/Message-Ressource aufgerufen wird (DELETE): &lt;<BR>&gt;
 Filter-Queue Pfad: {{{app/controllers/<project-name-space>/filter/<name>/delete}}}</li>
</ol>
<p>Es können beliebig viele Filter in den jeweiligen Filter-Queues abgelegt
werden, wobei alle Filter entsprechend ihrer lexikalischen Sortierreihenfolge
nacheinander aufgerufen werden:</p>
<p><code>unfiltered +-------+   +-------+   +-------+ filtered</code>&lt;<BR>&gt; <br />
<code>----------&gt;| 1-fil |--&gt;| 2-fil |...| n-fil |---------&gt;</code>&lt;<BR>&gt;  <br />
<code>message    +-------+   +-------+   +-------+ message</code></p>
<p>Wird ein Filter in die entsprechende Filter-Queue (Verzeichnis im Dateisystem)
kopiert, wird dieser automatisch zur Laufzeit dem ECS hinzugefügt. Es ist keine
Konfiguration oder gar ein Neustart des ECS notwenig (zero configuration;
convention over configuration).</p>
<p>=== Filter Template ===
Der Filter muß als Ruby Modul vorliegen und folgenden Aufbau besitzen:
{{{
modul BeliebigerModulname
  def self.start
    # hier kommt der eigentliche Filter
  end
end
}}}
Natürlich kann über die Startmethode des Moduls auch eine entsprechende Klasse
für eine objektorientierte Filterimplementierung angestoßen werden. Generell
darf zur Realisierung des Filters auf die komplette Ruby Funktionalität
zurückgegriffen werden.</p>
<p>Als API zum ECS wird durch die Konstante {{{FILTER_API}}} ein entsprechendes
Objekt bereitgestellt, mit dessen Hilfe auf die notwendigen ECS Objekte
zugegriffen werden kann. Momentan sind dies:</p>
<ol>
<li>
<p>{{{FILTER_API.params}}} Über diesen Hash kann unter anderem auf den Querystring des HTTP Aufrufs zugegriffen werden:
 {{{
 http://ecs.rus.uni-stuttgart.de/numlab/exercises/23?properties=name,description
 ...
 elements = FILTER_API.params["elements"].split(",")
 ...
 }}}</p>
</li>
<li>
<p>{{{FILTER_API.record}}} Dieses Objekt erlaubt unter anderem den Zugriff auf die zu filternde Message:
 {{{
 message = FILTER_API.record.body
 }}}</p>
</li>
</ol>
<p>== Transportprotokoll und Anwendungsprotokoll ==
Als Transport-/Anwendungsprotokoll dient HTTP 1.1 .</p>
<p>== Beispiele ==
Wie man den ECS konkret nutzt und als Client bedient, wird anhand einiger einfacher [[/examples|Beispiele]] erläutert.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
